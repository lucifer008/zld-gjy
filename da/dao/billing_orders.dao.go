// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"zld-jy/da/domain"
)

func newBillingOrder(db *gorm.DB) billingOrder {
	_billingOrder := billingOrder{}

	_billingOrder.billingOrderDo.UseDB(db)
	_billingOrder.billingOrderDo.UseModel(&domain.BillingOrder{})

	tableName := _billingOrder.billingOrderDo.TableName()
	_billingOrder.ALL = field.NewAsterisk(tableName)
	_billingOrder.ID = field.NewInt64(tableName, "Id")
	_billingOrder.CusID = field.NewInt64(tableName, "Cus_Id")
	_billingOrder.CompanyName = field.NewString(tableName, "company_name")
	_billingOrder.ApplyNo = field.NewString(tableName, "apply_no")
	_billingOrder.ApplyAmount = field.NewFloat64(tableName, "apply_amount")
	_billingOrder.ApplyDate = field.NewTime(tableName, "apply_date")
	_billingOrder.Status = field.NewInt32(tableName, "status")
	_billingOrder.BillingNo = field.NewString(tableName, "billing_no")
	_billingOrder.TaxpayerIDNumber = field.NewString(tableName, "taxpayer_ID_number")
	_billingOrder.Tel = field.NewString(tableName, "tel")
	_billingOrder.Address = field.NewString(tableName, "address")
	_billingOrder.BankName = field.NewString(tableName, "bank_name")
	_billingOrder.BankAccount = field.NewString(tableName, "bank_account")
	_billingOrder.ConsigneePerson = field.NewString(tableName, "consignee_person")
	_billingOrder.ConsigneeProvinceCode = field.NewString(tableName, "consignee_province_code")
	_billingOrder.ConsigneeCityCode = field.NewString(tableName, "consignee_city_code")
	_billingOrder.ConsigneeAreaCode = field.NewString(tableName, "consignee_area_code")
	_billingOrder.ConsigneeAddress = field.NewString(tableName, "consignee_address")
	_billingOrder.ConsigneeEmail = field.NewString(tableName, "consignee_email")
	_billingOrder.ConsigneeTel = field.NewString(tableName, "consignee_tel")
	_billingOrder.BillingDate = field.NewTime(tableName, "billing_date")

	_billingOrder.fillFieldMap()

	return _billingOrder
}

type billingOrder struct {
	billingOrderDo billingOrderDo

	ALL                   field.Asterisk
	ID                    field.Int64   // 开票Id
	CusID                 field.Int64   // 客户Id
	CompanyName           field.String  // 公司名称
	ApplyNo               field.String  // 发票申请单号
	ApplyAmount           field.Float64 // 申请金额
	ApplyDate             field.Time    // 申请时间
	Status                field.Int32   // 票据状态(0 待申请 1 开票中 2 已开票 3 已驳回 4作废)
	BillingNo             field.String  // 发票编号
	TaxpayerIDNumber      field.String  // 纳税人识别号
	Tel                   field.String  // 电话
	Address               field.String  // 地址
	BankName              field.String  // 开户银行
	BankAccount           field.String  // 开户账户
	ConsigneePerson       field.String  // 收货人
	ConsigneeProvinceCode field.String  // 收货省份Code
	ConsigneeCityCode     field.String  // 收货城市Code
	ConsigneeAreaCode     field.String  // 收货地区code
	ConsigneeAddress      field.String  // 收货详细地址
	ConsigneeEmail        field.String  // 收货人邮箱
	ConsigneeTel          field.String  // 收货人电话
	BillingDate           field.Time    // 开票时间

	fieldMap map[string]field.Expr
}

func (b billingOrder) Table(newTableName string) *billingOrder {
	b.billingOrderDo.UseTable(newTableName)
	return b.updateTableName(newTableName)
}

func (b billingOrder) As(alias string) *billingOrder {
	b.billingOrderDo.DO = *(b.billingOrderDo.As(alias).(*gen.DO))
	return b.updateTableName(alias)
}

func (b *billingOrder) updateTableName(table string) *billingOrder {
	b.ALL = field.NewAsterisk(table)
	b.ID = field.NewInt64(table, "Id")
	b.CusID = field.NewInt64(table, "Cus_Id")
	b.CompanyName = field.NewString(table, "company_name")
	b.ApplyNo = field.NewString(table, "apply_no")
	b.ApplyAmount = field.NewFloat64(table, "apply_amount")
	b.ApplyDate = field.NewTime(table, "apply_date")
	b.Status = field.NewInt32(table, "status")
	b.BillingNo = field.NewString(table, "billing_no")
	b.TaxpayerIDNumber = field.NewString(table, "taxpayer_ID_number")
	b.Tel = field.NewString(table, "tel")
	b.Address = field.NewString(table, "address")
	b.BankName = field.NewString(table, "bank_name")
	b.BankAccount = field.NewString(table, "bank_account")
	b.ConsigneePerson = field.NewString(table, "consignee_person")
	b.ConsigneeProvinceCode = field.NewString(table, "consignee_province_code")
	b.ConsigneeCityCode = field.NewString(table, "consignee_city_code")
	b.ConsigneeAreaCode = field.NewString(table, "consignee_area_code")
	b.ConsigneeAddress = field.NewString(table, "consignee_address")
	b.ConsigneeEmail = field.NewString(table, "consignee_email")
	b.ConsigneeTel = field.NewString(table, "consignee_tel")
	b.BillingDate = field.NewTime(table, "billing_date")

	b.fillFieldMap()

	return b
}

func (b *billingOrder) WithContext(ctx context.Context) *billingOrderDo {
	return b.billingOrderDo.WithContext(ctx)
}

func (b billingOrder) TableName() string { return b.billingOrderDo.TableName() }

func (b billingOrder) Alias() string { return b.billingOrderDo.Alias() }

func (b *billingOrder) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := b.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (b *billingOrder) fillFieldMap() {
	b.fieldMap = make(map[string]field.Expr, 21)
	b.fieldMap["Id"] = b.ID
	b.fieldMap["Cus_Id"] = b.CusID
	b.fieldMap["company_name"] = b.CompanyName
	b.fieldMap["apply_no"] = b.ApplyNo
	b.fieldMap["apply_amount"] = b.ApplyAmount
	b.fieldMap["apply_date"] = b.ApplyDate
	b.fieldMap["status"] = b.Status
	b.fieldMap["billing_no"] = b.BillingNo
	b.fieldMap["taxpayer_ID_number"] = b.TaxpayerIDNumber
	b.fieldMap["tel"] = b.Tel
	b.fieldMap["address"] = b.Address
	b.fieldMap["bank_name"] = b.BankName
	b.fieldMap["bank_account"] = b.BankAccount
	b.fieldMap["consignee_person"] = b.ConsigneePerson
	b.fieldMap["consignee_province_code"] = b.ConsigneeProvinceCode
	b.fieldMap["consignee_city_code"] = b.ConsigneeCityCode
	b.fieldMap["consignee_area_code"] = b.ConsigneeAreaCode
	b.fieldMap["consignee_address"] = b.ConsigneeAddress
	b.fieldMap["consignee_email"] = b.ConsigneeEmail
	b.fieldMap["consignee_tel"] = b.ConsigneeTel
	b.fieldMap["billing_date"] = b.BillingDate
}

func (b billingOrder) clone(db *gorm.DB) billingOrder {
	b.billingOrderDo.ReplaceDB(db)
	return b
}

type billingOrderDo struct{ gen.DO }

func (b billingOrderDo) Debug() *billingOrderDo {
	return b.withDO(b.DO.Debug())
}

func (b billingOrderDo) WithContext(ctx context.Context) *billingOrderDo {
	return b.withDO(b.DO.WithContext(ctx))
}

func (b billingOrderDo) ReadDB() *billingOrderDo {
	return b.Clauses(dbresolver.Read)
}

func (b billingOrderDo) WriteDB() *billingOrderDo {
	return b.Clauses(dbresolver.Write)
}

func (b billingOrderDo) Clauses(conds ...clause.Expression) *billingOrderDo {
	return b.withDO(b.DO.Clauses(conds...))
}

func (b billingOrderDo) Returning(value interface{}, columns ...string) *billingOrderDo {
	return b.withDO(b.DO.Returning(value, columns...))
}

func (b billingOrderDo) Not(conds ...gen.Condition) *billingOrderDo {
	return b.withDO(b.DO.Not(conds...))
}

func (b billingOrderDo) Or(conds ...gen.Condition) *billingOrderDo {
	return b.withDO(b.DO.Or(conds...))
}

func (b billingOrderDo) Select(conds ...field.Expr) *billingOrderDo {
	return b.withDO(b.DO.Select(conds...))
}

func (b billingOrderDo) Where(conds ...gen.Condition) *billingOrderDo {
	return b.withDO(b.DO.Where(conds...))
}

func (b billingOrderDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) *billingOrderDo {
	return b.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (b billingOrderDo) Order(conds ...field.Expr) *billingOrderDo {
	return b.withDO(b.DO.Order(conds...))
}

func (b billingOrderDo) Distinct(cols ...field.Expr) *billingOrderDo {
	return b.withDO(b.DO.Distinct(cols...))
}

func (b billingOrderDo) Omit(cols ...field.Expr) *billingOrderDo {
	return b.withDO(b.DO.Omit(cols...))
}

func (b billingOrderDo) Join(table schema.Tabler, on ...field.Expr) *billingOrderDo {
	return b.withDO(b.DO.Join(table, on...))
}

func (b billingOrderDo) LeftJoin(table schema.Tabler, on ...field.Expr) *billingOrderDo {
	return b.withDO(b.DO.LeftJoin(table, on...))
}

func (b billingOrderDo) RightJoin(table schema.Tabler, on ...field.Expr) *billingOrderDo {
	return b.withDO(b.DO.RightJoin(table, on...))
}

func (b billingOrderDo) Group(cols ...field.Expr) *billingOrderDo {
	return b.withDO(b.DO.Group(cols...))
}

func (b billingOrderDo) Having(conds ...gen.Condition) *billingOrderDo {
	return b.withDO(b.DO.Having(conds...))
}

func (b billingOrderDo) Limit(limit int) *billingOrderDo {
	return b.withDO(b.DO.Limit(limit))
}

func (b billingOrderDo) Offset(offset int) *billingOrderDo {
	return b.withDO(b.DO.Offset(offset))
}

func (b billingOrderDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *billingOrderDo {
	return b.withDO(b.DO.Scopes(funcs...))
}

func (b billingOrderDo) Unscoped() *billingOrderDo {
	return b.withDO(b.DO.Unscoped())
}

func (b billingOrderDo) Create(values ...*domain.BillingOrder) error {
	if len(values) == 0 {
		return nil
	}
	return b.DO.Create(values)
}

func (b billingOrderDo) CreateInBatches(values []*domain.BillingOrder, batchSize int) error {
	return b.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (b billingOrderDo) Save(values ...*domain.BillingOrder) error {
	if len(values) == 0 {
		return nil
	}
	return b.DO.Save(values)
}

func (b billingOrderDo) First() (*domain.BillingOrder, error) {
	if result, err := b.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*domain.BillingOrder), nil
	}
}

func (b billingOrderDo) Take() (*domain.BillingOrder, error) {
	if result, err := b.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*domain.BillingOrder), nil
	}
}

func (b billingOrderDo) Last() (*domain.BillingOrder, error) {
	if result, err := b.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*domain.BillingOrder), nil
	}
}

func (b billingOrderDo) Find() ([]*domain.BillingOrder, error) {
	result, err := b.DO.Find()
	return result.([]*domain.BillingOrder), err
}

func (b billingOrderDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*domain.BillingOrder, err error) {
	buf := make([]*domain.BillingOrder, 0, batchSize)
	err = b.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (b billingOrderDo) FindInBatches(result *[]*domain.BillingOrder, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return b.DO.FindInBatches(result, batchSize, fc)
}

func (b billingOrderDo) Attrs(attrs ...field.AssignExpr) *billingOrderDo {
	return b.withDO(b.DO.Attrs(attrs...))
}

func (b billingOrderDo) Assign(attrs ...field.AssignExpr) *billingOrderDo {
	return b.withDO(b.DO.Assign(attrs...))
}

func (b billingOrderDo) Joins(fields ...field.RelationField) *billingOrderDo {
	for _, _f := range fields {
		b = *b.withDO(b.DO.Joins(_f))
	}
	return &b
}

func (b billingOrderDo) Preload(fields ...field.RelationField) *billingOrderDo {
	for _, _f := range fields {
		b = *b.withDO(b.DO.Preload(_f))
	}
	return &b
}

func (b billingOrderDo) FirstOrInit() (*domain.BillingOrder, error) {
	if result, err := b.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*domain.BillingOrder), nil
	}
}

func (b billingOrderDo) FirstOrCreate() (*domain.BillingOrder, error) {
	if result, err := b.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*domain.BillingOrder), nil
	}
}

func (b billingOrderDo) FindByPage(offset int, limit int) (result []*domain.BillingOrder, count int64, err error) {
	result, err = b.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = b.Offset(-1).Limit(-1).Count()
	return
}

func (b billingOrderDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = b.Count()
	if err != nil {
		return
	}

	err = b.Offset(offset).Limit(limit).Scan(result)
	return
}

func (b billingOrderDo) Scan(result interface{}) (err error) {
	return b.DO.Scan(result)
}

func (b billingOrderDo) Delete(models ...*domain.BillingOrder) (result gen.ResultInfo, err error) {
	return b.DO.Delete(models)
}

func (b *billingOrderDo) withDO(do gen.Dao) *billingOrderDo {
	b.DO = *do.(*gen.DO)
	return b
}
